Syntaxe des templates
~~~~~~~~~~~~~~~~~~~~~

Introduction
============
Fab dispose d'un système simple de templates qui permettent d'avoir une 
séparation nette entre la présentation et le code. Les templates peuvent être
utilisés pour générer n'importe quelle sortie au format texte (texte brut, xml,
html, rtf, etc.)

Le système de templates mis en oeuvre vise plusieurs objectifs :

- avoir une syntaxe très simple, facile à comprendre
- permettre de gagner du temps : écrire un template doit prendre beaucoup moins
  de temps que de générer à la main la sortie attendue
- permettre, au moins en théorie, que les templates soient édités avec un outil
  standard (par exemple un éditeur html, éventuellement wysiswyg)
- avoir un système rapide (dans l'idéal, aussi rapide que si on avait codé à la
  main tous les "``echo xxx``" requis)
- offrir des fonctions de haut niveau : afficher facilement les résultats d'une
  recherche (loop), générer une table ds matières, etc.

Historique
==========
- La version 1 du système de template reprends ce qu'on avait dans BisWeb et 
  Bis 4.0 (champs entre crochets, bloc optionnels entre parenthèses et rien 
  d'autre).
- La version 2 améliore les choses en greffant plus de possibilités : blocs if
  et loop, balise opt pour les blocs optionnels, etc. La mise en oeuvre est faite
  à base d'expressions régulières, ce qui devient assez vite ingérable.
- La version 3 est une réécriture complète basée sur un parser xml. Les 
  templates doivent désormais être des fichiers xml valides. La syntaxe des 
  champs utilise maintenant le signe ``$`` et les accolades ``{ }``. Ajout de 
  plusieurs tags (if/else/elseif, switch/case/default, etc) et d'attributs 
  utilisables dans tous les tags (``if="xx"``, ``test="xxx"``, ...). 
  Système de templates match.

Mise en oeuvre
==============
Un template doit être un fichier ou un fragment xml bien formé. Fab ajoute 
automatiquent un tag racine au fichier s'il s'agit d'un fragment xml. Cela permet 
d'avoir le même système de templates pour des documents xhtml et, par exemple, 
des templates générant une sortie au format csv.

Remarque :

Même si un template doit être au format xml, on peut vouloir écrire du texte contenant des caractères
qui ne soient pas interprétés par le parser xml : il suffit pour cela de les include dans un bloc 
CDATA :

<![CDATA[
Ce bloc peut contenir n'importe quels caractères tels que des $ des signes < et >, etc.
Ils ne seront pas interprétés par le parser xml
]]>


Le système se compose de trois grands groupes d'éléments :

- Des zones de données : il s'agit de balises qui apparaissent dans le code du 
  template et  qui, lors de l'instanciation du template, seront remplacés par 
  une valeur : ::

  <h1>$titre</h1>
  <h1 class="$class">{$titoriga:$titorigm:"sans titre"}</h1>
 		
- des attributs qui peuvent être ajoutés à n'importe quel tag : ::

	<div id="adminBar" test="User::isAdmin()">
    	<a href="#">Créer une nouvelle base de données</a>
    	...
	</div>

- des tags : ::

	<loop on="$selection">...</loop>
	<if test="xxx">...<if>
	<switch test="xxx"><case test="yyy">...</case><default></switch>
	etc.

Commentaires
------------
Les commentaires doivent être indiqués en utilisant la syntaxe xhtml : ::

	<!-- commentaire -->

Ces commentaires sont supprimés de la sortie si l'option de configuration 
*templates.removehtmlcomments* est activée.

Remarque : précédemment, il existait un second type de commentaires utilisant la 
même syntaxe qu'en C : ``/* commentaire */``. Pour le moment, ce type de 
commentaire n'est plus géré, car cela crée un conflit avec les expressions xpath 
utilisées dans les templates match. Il seront activés si une solution est 
trouvée.

Zones de données
----------------
(ce qu'avant, on appellait des "champs").

Lors de l'instanciation du template, toutes les zones de données sont évaluées
et remplacées par les données correspondantes fournies lors de l'appel à 
``Template::Run``.

Il existe deux syntaxes possibles : la syntaxe simple et la syntaxe étendue.

Syntaxe simple
..............
Exemple : ::

	$title

Un signe dollar suivi d'un identifiant (sensible à la casse).

Syntaxe étendue
...............
Exemples : ::

	{$title:'pas de titre'}
	{Config::get('env')}

Il s'agit d'une expression saisie entre accolades.
Il peut s'agir d'une expression simple (par exemple ``{$titre}`` qui fait 
exactement la même chose que ``$titre``) ou d'une expression plus complexe 
(par exemple ``{strtolower($titre)}`` qui affiche la version en minuscules du 
titre).

En fait il est possible de saisir n'importe quelle expression (c'est-à-dire 
quelque chose qui retourne une valeur). La syntaxe est très intuitive 
puisqu'elle ressemble fortement à la syntaxe utilisée en php).

Fab ajoute un nouvel opérateur (le signe ":") qui permet de créer un "collier" 
d'expressions.

Exemple : ::
	
	{$titoriga:$titorigm:"pas de titre"}

Dans ce cas, la première expression (``$titoriga``) sera évaluée. Si elle retourne
quelque chose (i.e pas une chaine vide), on s'arrête là et on retourne cette 
valeur. Sinon, on passe à la seconde, et ainsi de suite.

Si aucune des expressions ne retourne une valeur, rien ne sera affiché (tout ce 
qu'il y a entre les accolades disparaît de la sortie générée par le template).

Remarques :

- pour des raisons de compatibilité ascendante, l'ancienne syntaxe 
  utilisant des crochets utilisée dans les anciennes versions du gestionnaire de 
  templates est également supportée : ::

	[title] === $title
	[titoriga:titorigm] === {$titoriga:$titorigm}

- les zones de données sont utilisables dans du texte et dans la valeur d'un 
  attribut d'un tag mais ne peuvent pas constituer un nom de tag ou un nom 
  d'attribut (sinon, le template ne serait plus du xml bien formé). Vous pouvez 
  donc écrire ``<h1>$titre</h1>`` ou ``<h1 class="$titre" id="$id>...</h1>``
  mais pas ``<h1 $attr="un">...</h1>`` ou ``<$tag>xxx</$tag>``

Lorsqu'une zones de données est utilisée comme valeur d'un attribut, et que la 
zone de données ne retourne pas de valeur, l'attribut devient automatiquement
optionnel.

Par exemple, si ``$class`` n'est pas définit, le template suivant 
``<h1 class="$class">...</h1>`` générera ``<h1>...</h1>`` et non pas
``<h1 class="">...</h1>``
	
Attributs
---------
Fab reconnaît un certains nombres d'attributs qui sont utilisables dans les 
templates reposant sur un balisage.

Bloc optionnel : ``test="condition"``
.....................................
L'attribut "``test``" peut être ajouté à n'importe quel tag html. Il représente 
une condition qui peut éventuellement contenir des zones de données. Lors de 
l'exécution la condition est évaluée et **l'ensemble du bloc, tag compris, sera 
supprimé si la condition n'est pas remplie**.

Exemple : ::

	<div test="User::isAdmin($user)" id="adminBar" >...</div>

Tag optionnel : ``if="condition"``
..................................

L'attribut "``if``" peut être ajouté à n'importe quel tag html. Il représente 
une  condition qui peut éventuellement contenir des zones de données. Lors de 
l'exécution la condition est évaluée et le tag ne sera affiché que si la 
condition est remplie. **Les éléments contenus dans le bloc, eux, sont toujours 
affichés**, que la condition soit remplie ou non.

Exemple : ::
	
	<a href="$link" if="$link">$titre</a>
		
Si on a un lien, générera ::

	<a href="http://xxx">Titre du doc</a>
		
Sinon, générera : ::
	
	Titre du doc
		
Remarques :
- on peut combiner, dans un même tag, les attributs ``test`` et ``if``.
- le choix des noms (test et if) ne me plait toujours pas.... chercher encore...

Remarque de Youenn : opt à la place de if. if est court mais en lisant if='$param', on n'a pas 
directement à l'esprit (en tout cas moi) que si $param est vide, le mot if va disparaître
de la sortie, alors qu'en lisant opt='$param' à la place, ça me semble plus évident.

Bloc ignoré : ``ignore="true"``
...............................
(implémenté)
Le bloc est complètement ignoré dans la sortie généré par le template (ie : ol
n'apparaîtra pas).

Bloc collapsé : ``collapse="true"``
.........................///......
(implémenté)
Le bloc est remplacé par son contenu

Bloc non parsé : ``noparse="true"``
................................... ::
	<style noparse="true">
	a{color:red}
	</style>

peut-être qu'un tag serait plus utile qu'un attribut (ou peut-être qu'il faut
les deux ?) ::
	<noparse>
		<style>
			a{color: red}
		</style>
	</noparse>

remarques : non implémenté, réfléchir à un meilleur nom.

Tags
----

Blocs optionnels : ``<opt>``
............................
Exemple : ::
	
	<opt>Le titre est $titre<br /></opt><opt>L'auteur est $auteur<br /></opt>

Blocs ``if/elseif/else``
........................
Exemple : ::
	
	<if test="xxx">
		...
	</if>
	<elseif test="xxx">
		...
	</elseif>
	<else>
		...
	</else>

Blocs ``switch/case/default``
.............................
Exemple : ::
	
	<switch test="xxx">		<!-- l'attribut 'test' optionnel -->
		<case test="xxx">	<!-- où "xxx" est une valeur possible pour l'expression du switch -->
			...
		</case>
		<case test="yyy">
			...
		</case>
		<default>
			...
		</default>
	</switch>
	
Boucles ``loop``
................
Exemple : ::
	
	<loop on="$selection" as="$i,$j">
		...
	</loop>
	
Si l'attribut 'as' ne spécifie qu'une seule variable $var, alors, dans le corps du loop,
$var donnera accès à la valeur et non à l'index en cours : équivalent à $j dans l'exemple précédent.


Templates : le tag template fait l'object d'une documentation séparée dans le fichier template.txt
..................................................................................................
Exemple : ::
	
	<template match="//copyright" year="">
		<hr />
		Copyright $year BDSP
	</template>
	
	<copyright year="2007"/>

Il s'agit en fait de pouvoir définir des templates "internes" qui sont instanciés par un "pré-processeur"
quand il rencontre un tag dont le nom est équivalent à la valeur du tag 'match' du template ('copyright' dans l'exemple).

Cf documentation séparée : template.txt

Prévu, mais pas encore implémenté
---------------------------------

Inclusion de fichier : ``<include>``
....................................
	<include file="xxx" />
	
	
Table des matières : ``<tableofcontents>``
..........................................
	<tableofcontents ...options...>...</tableofcontens>

options envisageables :
- insérer avant/après le texte
- niveau max de titre à prendre en compte (h1..h3 par exemple)
- ajouter des liens oui/non
- créer un lien "retour au sommaire" pour les titres
- ...


TODO : faire doc pour les auto-include
Fonctions
---------
autoId()
........
Génère automatiquement un ID pour l'élément auquel il est appliqué.

Fonctionnement : 
prends l'id ou le 'name' du noeud en cours et remonte l'arbre 
comme ça jusqu'à la racine. 
Si on ne trouve rien, on prends le nom du tag du noeud en cours. 
Si cet id a déjà été utilisé, on numérote (typdoc, typdoc2, typdoc3...)

lastId()
........
Retourne le dernier id généré par autoId() ou vide si autoId() n'a pas été 
appellé avant.